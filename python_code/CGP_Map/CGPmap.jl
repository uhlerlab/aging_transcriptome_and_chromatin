using HDF5
using JLD
using MAT
using Graphs
using DataFrames
using LinearAlgebra
using Statistics
using Interpolations
using SparseArrays



#input file is generated by HiC-Pro, with 3 columns: row_index, column_index, entry
function read_simple_contact_map(input_file,hg19_info,bin_size);

	chr_length=hg19_info[:length];
	X=readtable(input_file,separator='\t',header=false);
	chr2bins,bin2loc=generate_arbitrary_mapping_files(hg19_info,bin_size);
	N=size(bin2loc,1);
	M=sparse(X[:,1],X[:,2],X[:,3],N,N);
	if ~isequal(M,M');
		tmp=M-spdiagm(diag(M));
		M=M+tmp';
	end

	return M;
end

#input A is the interaction matrix
function construct_GPC(A,Gene,G2B_dict);

	dark_bins=findall(sum(A,dims=1).==0);
	N=length(Gene);
	GPC=zeros(N,N);
	for i=1:length(Gene)
		display(i)
		m1=G2B_dict[Gene[i]];
		if length(m1).==1
			if m1 in dark_bins
				b1=[];
			else
				b1=[m1];
			end
		else
			b1_aux=BitArray(undef,m1[2]-m1[1]+1,1);
			b1=collect(m1[1]:m1[2]);
			for k1=1:length(b1_aux)
				b1_aux[k1]=b1[k1] in dark_bins;
			end
			b1=b1[vec(.!b1_aux)];
		end

		for j=i:length(Gene)
			m2=G2B_dict[Gene[j]];

			if length(m2).==1
				if m2 in dark_bins
					b2=[];
				else
					b2=[m2];
				end
			else
				b2_aux=BitArray(undef,m2[2]-m2[1]+1,1);
				b2=collect(m2[1]:m2[2]);
				for k2=1:length(b2_aux)
					b2_aux[k2]=b2[k2] in dark_bins;
				end
				b2=b2[vec(.!b2_aux)];
			end

			if isempty(b1) || isempty(b2)
				GPC[i,j]=NaN;
				GPC[j,i]=NaN;
			elseif length(b1)==1 && length(b2)==1
				e1=(A[b1,b2]+A[b2,b1])/2;
				e2=(A[b1,b2]+A[b2,b1])/2;
				GPC[i,j]=e1[1];
				GPC[j,i]=e2[1];
			else
				Atmp=(A[b1,b2]+A[b2,b1]')/2;
				GPC[i,j]=maximum(Atmp);
				GPC[j,i]=maximum(Atmp);
				#distance can also be represented by the mean contact frequencies
				#GPC[i,j]=mean(Atmp);
				#GPC[j,i]=mean(Atmp);
			end
		end
	end
	#the only case GPC is NaN is, either genes belong completely to the dark bins..

	return GPC;
end

function generate_GPC_null_aux(hg19_info,gene_st,gene_ed,chr,bin_size,GPC);

	N=length(gene_st);

	chr_id=indexin(chr,hg19_info[:chr]);
	Z=broadcast(-,chr_id,chr_id');
	is_inter=(Z.!=0);
	inter_expect=sum(sum(GPC.*is_inter))/sum(sum(is_inter));

	all_d=Array{Int64}(undef,0);
	all_w=Array{Float64}(undef,0);
	maxL=convert(Int64,ceil(maximum(hg19_info[:length])/bin_size));

	for c=1:24;
		iz=LinearIndices(chr_id)[findall(chr_id.==c)];
		z=gene_st[iz];
		GPC_chr=GPC[iz,iz];
		Z=floor.(abs.(broadcast(-,z,z'))/bin_size.+1);
		d_pairs=triu(Z);
		(u,v,w)=findnz(sparse(d_pairs));
		w=convert(Array{Int64,1},w).-1;

		(u2,v2,gpc2)=findnz(sparse(triu(GPC_chr.+1)));
		gpc2=gpc2.-1;

		all_d=[all_d;w];
		all_w=[all_w;gpc2];

		all_d=round.(Int,all_d);
		all_w=convert(Array{Float64,1},all_w);

	end

	x=all_d;
	y=log10.(all_w.+1);

	xs,ys_smooth=local_smoothing(x,y);

	xs_all=collect(0:1.0:maxL-1);
	ys_all=zeros(size(xs_all));

	for k=1:length(xs_all);
		ik=findall(xs.==xs_all[k]);
		if ~isempty(ik)
			ys_all[k]=ys_smooth[ik][1];
		end
	end

	A_x=findall(ys_all.>0);
	knots=(A_x,);
	itp=interpolate(knots,ys_smooth, Gridded(Linear()));
	A_nz=findall(ys_all.==0);
	A_nz=A_nz[A_nz.<=length(itp)];
	for i=1:length(A_nz);
		ys_all[A_nz[i]]=itp[A_nz[i]];
	end
	all_intra_expect=10 .^ys_all;

	GPC_intra_aux=zeros(N,N);
	for c=1:24;
		expect_d=all_intra_expect;
		iz=LinearIndices(chr_id)[findall(chr_id.==c)];
		z=gene_st[iz];
		Z=floor.(abs.(broadcast(-,z,z'))/bin_size.+1);

		d_pairs=triu(Z);
		(u,v,w)=findnz(sparse(d_pairs));
		w=convert(Array{Int64,1},w)
		expect_ct=expect_d[w];

		X_chr=sparse(iz[u],iz[v],expect_ct,N,N);
		X_chr=X_chr+X_chr';
		GPC_intra_aux=GPC_intra_aux+X_chr;
	end

	GPC_intra_aux=GPC_intra_aux-diagm(0 => diag(GPC_intra_aux));
	GPC_intra_aux=GPC_intra_aux/sum(GPC_intra_aux)*sum(GPC.*(is_inter.==0));
	GPC_null_aux=is_inter*inter_expect+GPC_intra_aux;

	return GPC_null_aux;

end

#generate the null model for the 1D component
function generate_GPC_null(GPC,GPC_null_aux,err_threshold);

	W=GPC-diagm(0 => diag(GPC));
	W=replace!(W, NaN=>0)
	dark_bins=LinearIndices(1:size(W)[1])[findall(sum(W,dims=2).==0)];

	coverage_real=sum(W,dims=2);
	invC=1 ./coverage_real;
	invC=invC[:,1];
	invC=replace!(invC, Inf=>0);
	invC=diagm(0 => invC);

	coverage_est=sum(W,dims=2)/sqrt(sum(W));
	coverage_est=dropdims(coverage_est,dims=2)
	coverage_est[dark_bins]=repeat([0],length(dark_bins));
	iy=coverage_est;

	f_W=GPC_null_aux;

	tmp=f_W*iy;
	y_new=invC*tmp;
	coverage_est_new=1 ./y_new;
	coverage_est_new=replace!(coverage_est_new, Inf=>0);
	nm=sum((coverage_est_new*coverage_est_new').*f_W);
	coverage_est_new=coverage_est_new/sqrt(nm)*sqrt(sum(W));

	err=sum(abs.(coverage_est_new-coverage_est));

	while err>err_threshold;
		display(err);
		coverage_est=coverage_est_new.+0;
		iy=coverage_est;
		tmp=f_W*iy;
		y_new=invC*tmp;
		coverage_est_new=1 ./y_new;
		coverage_est_new=replace!(coverage_est_new, Inf=>0);
		nm=sum((coverage_est_new*coverage_est_new').*f_W);
		coverage_est_new=coverage_est_new/sqrt(nm)*sqrt(sum(W));
		err=sum(abs.(coverage_est_new-coverage_est));
	end

	E_W=(coverage_est_new*coverage_est_new').*f_W;
	GPC_null=E_W;
	return E_W;
end

function local_smoothing(x,y);

    span=0.01;
    v=sortperm(x);
    x=x[v];
    y=y[v];
    ux=unique(x);
    uy_smooth=zeros(size(ux));
    n=Int(floor(length(x)*span/2));

    mm=zeros(size(x));
    L=2*n+1;
    i=n+1;
    st=1;
    ed=i+n;
    mm[i]=mean(y[st:ed]);
    for i=n+2:length(y)-n;
        ed=ed+1;
        mm[i]=mm[i-1]+y[ed]/L-y[st]/L;
        st=st+1;
    end
    for i=1:n
        mm[i]=mean(y[1:n+i]);
    end
    for i=1:n;
        mm[end-n+i]=mean(y[end-n+1-n+i:end]);
    end

    for i=1:length(ux);
        iz=findall(x.==ux[i]);
        uy_smooth[i]=mean(mm[iz]);
    end

    return ux,uy_smooth;

end

function load_annotation(annot_file);
	vars=matread(annot_file)
	Gene=vars["Gene_name"];
	ENSG=vars["Gene_id"];
	strand=vars["strand"];
	gene_st=vars["st"];
	gene_ed=vars["ed"];
	chr=vars["chr"];
	TPM=vars["TPM"];
	TPM_pe=vars["TPM_pe"]
	celltype=vars["celltype"]
	return Gene, ENSG, strand, gene_st, gene_ed, chr, celltype, TPM, TPM_pe;
end

function generate_arbitrary_mapping_files(hg19_info,bin_size);

	num_of_chromosomes=size(hg19_info,1);
	chr2bins=zeros(Int64,2,num_of_chromosomes);
	chr_length=hg19_info[:length];
	chr_num_bins=ceil.(Int,chr_length/bin_size);
	chr2bins[2,:]=cumsum(chr_num_bins)'.-1;
	chr2bins[1,1]=0;
	chr2bins[1,2:end]=chr2bins[2,1:end-1].+1;
	X=chr2bins.+1;
	bin2loc=zeros(Int64,3,X[2,end]);
	for c=1:size(hg19_info,1);
		bin2loc[1,X[1,c]:X[2,c]].=c-1;
		bin2loc[2,X[1,c]:X[2,c]]=collect(1:bin_size:chr_length[c])';
		bin2loc[3,X[1,c]:X[2,c]]=[collect(bin_size:bin_size:chr_length[c])' chr_length[c]];
	end
	return chr2bins,bin2loc;

end

function define_hg19_genome();

	hg19_info=DataFrame();
	hg19_info[:id]=1:25;
	hg19_info[:chr]=["chr1","chr2","chr3","chr4","chr5","chr6","chr7","chr8","chr9","chr10",
	"chr11","chr12","chr13","chr14","chr15","chr16","chr17","chr18","chr19","chr20","chr21",
	"chr22","chrX","chrY","chrM"];
	hg19_info[:length]=[249250621,243199373,198022430,191154276,180915260,171115067,159138663,
	146364022,141213431,135534747,135006516,133851895,115169878,107349540,102531392,90354753,
	81195210,78077248,59128983,63025520,48129895,51304566,155270560,59373566,16571];

	return hg19_info;

end

function change_chr(hg19_info,chr)

	if typeof(chr)==Float64||typeof(chr)==Int64;
		chr2=hg19_info[:chr][hg19_info[:id].==chr][1];
	elseif typeof(chr)==String||typeof(chr)==SubString{String}||typeof(chr)==UTF8String
		chr2=hg19_info[:id][hg19_info[:chr].==chr][1];
	end

	return chr2;

end

function get_gene_to_bin_mapping(Gene,chr,gene_st,gene_ed,bin2loc);

	G2B_dict=Dict{String,Any}();
	for i=1:length(Gene)
        ch=chr[i];
        ch=change_chr(hg19_info,ch);
        st=gene_st[i];
        ed=gene_ed[i];
        p1=findall((bin2loc[1,:].==ch-1).*(bin2loc[2,:].<st))
        p2=findall((bin2loc[1,:].==ch-1).*(bin2loc[3,:].>ed))
        iz=intersect(p1,p2);
        #iz=find((bin2loc[1,:].==ch-1).*(bin2loc[2,:].<st).*(bin2loc[3,:].>ed));
        if ~isempty(iz)
            G2B_dict[Gene[i]]=iz[1];
        elseif ~isempty(p1) && ~isempty(p2)
            G2B_dict[Gene[i]]=[p1[end],p2[1]];
        else
            G2B_dict[Gene[i]]=[];
        end
	end

	return G2B_dict;

end
